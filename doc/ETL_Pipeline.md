# ETL pipeline モジュールについて

このモジュールでは、ETL処理を行うためのクラスや関数を提供します。

## 目次

- [目次](#目次)
- [はじめに](#はじめに)
  - [ETL処理とは](#etl処理とは)
    - [処理フロー](#処理フロー)
- [処理フローの概要](#処理フローの概要)
  - [CSV読込あり](#csv読込あり)
- [詳細](#詳細)
  - [データソースについて](#データソースについて)
  - [CSV読込について](#csv読込について)
    - [NOTE：ダウンロードしたCSVの項目名（タイトル行）について](#noteダウンロードしたcsvの項目名タイトル行について)
  - [conversion\_settingsについて](#conversion_settingsについて)
    - [NOTE: CSV読み込み：項目の自動判定について](#note-csv読み込み項目の自動判定について)
- [TODO](#todo)

## はじめに

### ETL処理とは

　ETL（Extract, Transform, Load）は、データ統合プロセスの重要な要素です。このモジュールでは、設定ファイル（TOML形式）に基づいて、複数のデータソースからデータを抽出し、一貫した形式に変換して、データベースに格納する一連の処理を自動化します。

#### 処理フロー

**1. Extract**（**抽出**）

複数のデータソースから生データを取得します：
- データベース接続による取得
- REST APIからのデータ取得
- CSVファイルからの読み込み（ジョブカン形式対応）

**2. Transform**（**変換**）

取得したデータを統一された形式に変換します：
- JSON形式への標準化
- データ型の適切な変換
- 必要に応じたデータクレンジング

**3. Load**（**ロード**）

変換されたデータを目的のデータベースに格納します。

## 処理フローの概要

### CSV読込あり

0. 変換設定`conversion_settings.toml` (以下`settings`) を読込
   1. `conversion_settings.toml`には、ETL処理の設定が記述されています
1. ジョブカンのサイトからCSVファイルをダウンロード
   1. [申請データをCSVでダウンロードする](https://jobcanwf.zendesk.com/hc/ja/articles/115000482007-申請データをCSVでダウンロードする)にあるように、申請データをCSV形式でダウンロードします
2. CSVファイルを読み込み、データソース(`RawDataSource`)に変換
   1. `settings`からCSV読み込み先のフォルダ/ファイルを指定、ファイル一覧を取得します
   2. 各CSVをフォームの種類 (`form_id`) ごとに読み込み、共通項目（および設定があれば追加項目・明細項目）を抽出します (`ParsedCSVData`に変換します)
   3. 抽出したデータを`RawDataSource`に変換します
3. データソースを変換し、データベースに格納
   1. `settings`を参照し、他のデータソースを生成します
   2. `settings`からデータベース接続情報を取得します
   3. `settings`からデータベースに格納するデータソース・変換設定を取得し、データベースに格納します

<details><summary>【コード例】</summary><div>

```python
from jobcan_di.database.data_pipeline.pipeline import execute_etl_pipeline
from jobcan_di.importer import parse_toml
from jobcan_di.importer.pipeline import merge_csv_as_data_source

# パイプライン定義をTOMLファイルから読み込む
p_toml = R"test\data\conversion_settings.toml"
c_settings = parse_toml(p_toml)
c_settings.csv2json.csv_import_settings.folder = R"../../../Downloads/request_20240101120000_jobcan_download_files"
c_settings.json2sql.table_definition.path = "../../../Downloads/output_data_4_1.db"
pipeline_def = c_settings.json2sql

# CSVファイルをデータソースとしてパイプライン定義にマージする
pipeline_def = merge_csv_as_data_source(pipeline_def, c_settings.csv2json)

# ETL処理を実行
execute_etl_pipeline(pipeline_def)
```

</div></details>

## 詳細

### データソースについて

　本モジュールでは、Extract (抽出) 処理は`DataSource`およびその継承クラスにより実装されます。`DataSource`クラスは、データの取得方法を定義するためのクラスであり、`extract_data`メソッドによりデータを取得します。データの取得方法は、データベース接続による取得、REST APIからのデータ取得、CSVファイルからの読み込みなどが考えられます。

　本モジュールでは、データの変換（ETLのTransform）段階の前処理として、データの1単位の形式を以下のように揃えています。データの1単位は、基本的にJSONのオブジェクトとして成り立つもののうち複数要素を格納するもの、すなわち`dict[str, Any]`か`tuple[str, Any]`として想定します。例えば1ユーザーに関する情報が1つの塊として取得できるとするならば、

- `{"userId": 12345, "userName": "John Doe", ...}`
- `[12345, "John Doe", ...]`

といったものが1単位として取得されます。本プログラムでは、データの抽出処理（ETLのExtract）を`DataSource`クラス（および継承クラス）の`extract_data`メソッドで行います。したがって、抽出処理の結果は1単位（`UnitOfResult`）のリスト（`list[UnitOfResult]`）となり、変換処理の入力はそれらとなります。

### CSV読込について

　読み込まれたCSVファイルは、フォームの種類 (`form_id`) ごとに1つの`ParsedCSVData`として読み込まれます。例えば指定したフォルダの下に10種50ファイルが存在する場合は、10個の`ParsedCSVData`が生成されます。

　ジョブカンでは、フォームはまず**汎用フォーム**、**経費精算フォーム**、**支払依頼フォーム**の3つに分類され、その下位分類として各申請書種が存在します（参考: [フォーム形式とは何ですか](https://jobcanwf.zendesk.com/hc/ja/articles/223307427-フォーム形式とは何ですか)）。さらに、汎用フォーム、経費精算フォーム、支払依頼フォームのそれぞれで共通の設定が**共通項目**として存在し、また各申請書種ごとに異なる設定が**追加項目**および**明細項目**として存在します（参考: [申請データをCSVでダウンロードする](https://jobcanwf.zendesk.com/hc/ja/articles/115000482007-申請データをCSVでダウンロードする)）。

　`conversion_settings.toml`でフォームの読み込み方法は以下の2通りが指定できます。ダウンロードしたCSVファイルのタイトル行（CSVの1行目）はいずれも`<共通項目>, ..., <追加項目>, .., <コメント>, <明細項目>, ...`という並びになっているため、自動判定を行う場合はこの行を参照します。

- 追加項目等を詳細に指定する方法（`[csv2json.<form_type>.<form_unique_key>]`のように別個の項目を立てて指定
  - データソース名を申請書の種類ごとに指定します
  - 読み込む列のタイトルや、読み込み後のJSONキー名、データ型等を指定します
- 自動判定する方法
  - フォームの種類が自動で判定され、それに応じて共通項目・追加項目・明細項目が自動で振り分けられます
    - フォームの種類は共通項目により判定されます
    - 追加項目・明細項目はEXCELで読み込んだ場合の列名（`X`や`AA`等）をJSONキー名として使用します
  - データソース名は`[csv2json.<form_type>.unnamed_<n>]`のように自動で振られます
    - 例: `csv2json.general_form.unnamed_1`, `csv2json.expense_form.unnamed_10`等

<details><summary>【具体例】</summary><div>

以下はCSVファイルのタイトル行の例です。このフォームは**支払依頼フォーム**であり、共通項目として`申請ID`～`口座名`（および`コメント`）が存在し、追加項目として`源泉徴収税額`～`新しい項目`が存在します。また、このフォームには明細項目が存在しないため、それに関する列は存在しません。

```csv
"申請ID","申請ステータス","最終承認日","承認者","フォーム名","タイトル","申請者メールアドレス","申請者コード","申請者名（姓）","申請者名（名）","申請日時","関連プロジェクト名","関連グループ名","関連申請タイトル","関連申請ID","事前申請タイトル","事前申請ID","支払依頼の内訳","計上日","金額","内容","支払予定日","振込手数料","源泉徴収税","支払先名","支払先登録番号","銀行コード","銀行名","支店コード","支店名","口座種別","口座番号","口座名","源泉徴収税額","請求書の添付","請求書の受取方法","支払頻度","備考","【申請にあたっての確認事項】","新しい項目","コメント"
```

</div></details>

#### NOTE：ダウンロードしたCSVの項目名（タイトル行）について

　同一の申請書種のCSVであっても項目名が一致しないケースがあります。

　**共通項目**について[web](https://jobcanwf.zendesk.com/hc/ja/articles/115000482007-申請データをCSVでダウンロードする)に記載されている項目と、実際にダウンロードされたCSVの項目名が異なる場合があります。こちらの原因は不明ですが、`optional_items`オプションを使用することで対応可能です。基本的に骨子は一致しており、一部のCSVファイルにおいて項目の過不足が生じている状態のため、最も項目数が多いものを基準に、不足が見られる項目を`optional_items`として指定します。

　例として、経費精算フォームの共通項目のうち、「支払先名」と「支払先登録番号」が存在する場合と存在しない場合があるとします。この場合、`common_items`には「支払先名」と「支払先登録番号」をともに指定し、`optional_items`にもこれらを指定することで、「支払先名」および「支払先登録番号」が存在しない申請書についても正常に処理できます。

```toml
# conversion_settings.toml

[csv2json.expense_form]
common_items = [
    # (他の項目...)
    ["支払先名", "payee_name", "", "説明"],
    ["支払先登録番号", "payee_registration_number", "", "説明"],
    # (他の項目...)
]

optional_items = ["支払先名", "支払先登録番号"]

# 以下省略
```

　次に**追加項目・明細項目**に関する項目名の不足に関してですが、これはジョブカンのCSVダウンロード機能が、対応するデータからタイトル行を自動生成している（と思われる）ことが原因だと考えられます。ダウンロードされるCSVはフォームごと、かつ含まれる申請書データが最大100件までのため、データが空の場合はタイトル行が生成されません。そのため、同一のフォームであっても項目名が異なる場合があります。

　例として、**経費明細**と**交通費明細**の明細項目を持つ経費精算フォームの全件が120件であるとします。ダウンロード時点で81件目以降の経費明細が空である場合、以下のようなCSVファイルが生成されます。以下のいずれの場合においても、フォームのタイプにより決定される共通項目（および追加項目）は存在します。

- 1つめのCSV（例: `request_交際費・立替精算_20240101120000_12345_1.csv`）
  - 1-100件目の申請書データが記載されており、経費明細と交通費明細の両方の項目が記入されている
- 2つめのCSV（例: `request_交際費・立替精算_20240101120000_12345_2.csv`）
  - 101-120件目の申請書データが記載されており、全ての申請書データについて経費明細の項目が空のため、経費明細の項目列が存在しない

### conversion_settingsについて

　`conversion_settings.toml`は、ETL処理の設定を記述するためのファイルです。

#### NOTE: CSV読み込み：項目の自動判定について

　はじめに、`conversion_settings.toml`では、`form_unique_key`と`form_name`を指定することで、申請書種ごとの詳細な設定（以下特殊化）が可能です。例えば以下のようなケースでは、フォーム名が「一般稟議書」である申請書種に対して、`form_unique_key`を`form_1_1`として指定しています。`form_unique_key`はデータソース名の一部であり（以下の場合はデータソース名 `csv2json.general_form.form_1_1`）、以降の処理ではその指定のためこの項目が使用されます。

```toml
[csv2json.general_form.form_1_1]
form_name = "一般稟議書"

# 以下省略
```

　特殊化は以下の3つの方法で行われます。このうち、②と③では追加・明細項目が[自動判定](#csv読込について)されます。特に③について、`form_unique_key`は`csv2json.<form_type>.unnamed_<n>`のように自動生成されます。`<n>`はデータソース名の連番であり、`csv2json.import_settings.csv_folder_path`に指定されたフォルダ内のCSVファイルの種類に応じて変化します（例: `unnamed_1`, `unnamed_15`等）。

- ① `form_unique_key`と`form_name`、および`common_items`/`detail_items`を指定
- ② `form_unique_key`と`form_name`のみを指定 (追加・明細項目は自動判定)
- ③ 指定なし (追加・明細項目は自動判定、`form_unique_key`は自動生成)

また、②と③では項目の自動判定が行われますが、この際に生成されるJSONキー（insertion_profileの`named_parameters`等で使用する、各データのキー）は、CSVファイルをExcelに読み込んだ際の列名（`A`, `B`, `C`等）をそのまま使用します。

- 例) `A`列 (1列目) が「申請ID」、`B`列 (2列目) が「申請ステータス」、…`Z`列 (26列目) が「コメント」、`AA`列 (27列目) が「明細項目1」、…
  - 共通項目（申請ID、申請ステータス、…）は特殊化なしに設定されているため、JSONキーはそれぞれ`"id"`, `"status"`, …となる
  - 追加項目や明細項目（明細項目1、…）を自動判定したとすると、それぞれのJSONキーは列名（`AA`, …）をそのまま使用する

## TODO

- データ構造
  - [ ] データソースの位置を一番外側に移動させたい (toml & クラス)
  - [ ] `jobcan_di.database.data_pipeline` を `jobcan_di.etl_pipeline` に変更
    - [ ] `jobcan_di.importer` は統合しない
      -  現在`jobcan_di.importer`で定義しているCSVファイルの読み込み方法はジョブカンのデータ形式に合わせた特殊な ものであり、一般性がない。
      - このため統合することは好ましくないが、CSVの読み込みの一部に一般性が見いだせるのであればそれを統合することも可能としたい
- データソース
  - [x] 複数データソースをまとめて処理
    - [x] ソース名の正規表現による指定を可能にする
      - [x] 正しく取得できていないようなので修正 -> `regex_source`に正規表現によるソースを指定した
    - [x] (CSV読込) データソース名の連番指定を追加
- CSV読み込み
  - [x] フォームの自動分類に失敗している
    - [x] すべて`general_form`と判定されていたため、一致する項目数が最も多い`form_type`を選択するように変更
    - [x] form_typeの共通項目について若干のゆれがあるようなので、`optional_items`オプション等を追加
    - [x] 追加・明細項目を指定せずに詳細項目を設定することを許容する
  - [x] 同一form_typeのCSVについて、列名が異なる場合の処理を記述
      - [x] 片方の列名がもう片方の列名と包含関係にある場合、大きいものを採用する
      - [x] それ以外の場合は、エラーを出力する
  - [x] conversion_settingsの個別フォームについて、form_nameとform_ukのみの指定を許容する
    - [x] 項目は自動判定を行い、データソース名のみを指定可能にする
  - [ ] `classify_form_type`でform_ukを引数とするようにし、関数を使用している箇所を修正
  - [ ] テーブル格納時は以下の構造としたい
    - 共通項目テーブル (x3)、追加項目テーブル (x全申請書種)、明細項目テーブル (x全申請書種)
  - [ ] 出力するJSONを階層化しない`flatten`オプションを追加
- ドキュメント等
  - etl_pipeline
    - [x] `convert_data_type_specific`について、データが空であり変換に失敗する場合 (例: `""`を`int`に変換) の挙動を記述
      - [x] int, float, bool への変換に際しては、空文字列/Noneの場合は`None`に変換する
      - [x] str への変換に際しては、空文字列/Noneの場合は`""`に変換する
  - CSV読み込み
    - [x] 列名等を指定しない場合の、自動生成される列名の説明を記述
    - [x] データソースの自動判定の際の、自動生成されるデータソース名の説明を記述
    - [x] 同一フォームのCSVについて、列名が異なる場合の対応方法を記述
      - 片方の列名がもう片方の列名と包含関係にある場合、大きいものを採用し、それ以外の場合はエラーを出力する
- テスト
  - CSV読み込み
    - [ ] 自動判定によるform_type分類が正しいかを検証するコードを追加
  - [ ] data_pipelineの`SQLiteDataSource`のためのテストコードを実装
- 未分類
  - [ ] コネクションプーリングのためのクラスを実装
  - [ ] insertion_profileでとりえあず`ON CONFLICT(id) DO NOTHING`を指定しているが、これでよいか検討
    - [ ] 何がコンフリクトしているかを確認する
